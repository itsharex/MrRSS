name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.1.0)'
        required: true
        type: string

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      tag: ${{ steps.get_version.outputs.tag }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      
      - name: Get version from input
        id: get_version
        run: |
          VERSION="${{ github.event.inputs.version }}"
          # Remove 'v' prefix if present
          VERSION="${VERSION#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT
      
      - name: Update version in wails.json
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          sed -i 's/"version": ".*"/"version": "'$VERSION'"/' wails.json
          sed -i 's/"productVersion": ".*"/"productVersion": "'$VERSION'"/' wails.json
      
      - name: Check if tag exists
        id: check_tag
        run: |
          git fetch --tags
          if git rev-parse ${{ steps.get_version.outputs.tag }} >/dev/null 2>&1; then
            echo "tag_exists=true" >> $GITHUB_OUTPUT
            echo "Tag ${{ steps.get_version.outputs.tag }} already exists"
          else
            echo "tag_exists=false" >> $GITHUB_OUTPUT
            echo "Tag ${{ steps.get_version.outputs.tag }} does not exist"
          fi
      
      - name: Create Git tag
        if: steps.check_tag.outputs.tag_exists == 'false'
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add wails.json
          git commit -m "Release ${{ steps.get_version.outputs.tag }}" || echo "No changes to commit"
          git tag ${{ steps.get_version.outputs.tag }}
          git push origin ${{ steps.get_version.outputs.tag }}
          git push origin HEAD:${{ github.ref_name }}
      
      - name: Generate changelog
        id: changelog
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          
          # Extract changelog for this version from CHANGELOG.md
          if [ -f "CHANGELOG.md" ]; then
            # Find the section for this version
            # Match pattern like "## [1.1.3] - 2025-11-22"
            awk -v ver="$VERSION" '
              BEGIN { found=0; print_section=0 }
              /^## \[/ {
                if (print_section) exit
                if ($0 ~ "\\[" ver "\\]") {
                  found=1
                  print_section=1
                  next
                }
              }
              print_section && /^## \[/ { exit }
              print_section { print }
              END {
                if (!found) {
                  print "## What'\''s Changed"
                  print ""
                  print "* Release version " ver
                }
              }
            ' CHANGELOG.md > RELEASE_NOTES.md
          else
            # Fallback to git log if CHANGELOG.md doesn't exist
            echo "## What's Changed" > RELEASE_NOTES.md
            git log $(git describe --tags --abbrev=0 HEAD^)..HEAD --pretty=format:"* %s (%h)" >> RELEASE_NOTES.md || echo "* Initial release" >> RELEASE_NOTES.md
          fi
          
          # Show what we extracted for debugging
          echo "=== Generated Release Notes ==="
          cat RELEASE_NOTES.md
          echo "==============================="
      
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.get_version.outputs.tag }}
          name: MrRSS ${{ steps.get_version.outputs.tag }}
          body_path: RELEASE_NOTES.md
          draft: false
          prerelease: false
          token: ${{ secrets.GITHUB_TOKEN }}

  build-release:
    name: Build ${{ matrix.platform }}-${{ matrix.arch }}
    needs: create-release
    runs-on: ${{ matrix.os }}
    permissions:
      contents: write
    strategy:
      matrix:
        include:
          # Linux builds
          - os: ubuntu-latest
            platform: linux
            arch: amd64
            ext: ''
          - os: ubuntu-latest
            platform: linux
            arch: arm64
            ext: ''
          # Windows builds
          - os: windows-latest
            platform: windows
            arch: amd64
            ext: '.exe'
          - os: windows-latest
            platform: windows
            arch: arm64
            ext: '.exe'
          # macOS builds
          - os: macos-latest
            platform: darwin
            arch: universal
            ext: '.app'
          # Note: We use universal builds for macOS which includes both amd64 and arm64
    
    steps:
      - uses: actions/checkout@v6
        with:
          ref: ${{ needs.create-release.outputs.tag }}
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'
      
      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'
      
      - name: Install Linux dependencies
        if: matrix.platform == 'linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev gcc pkg-config wget file libfuse2 imagemagick
          # Install ARM64 cross-compilation tools if needed
          if [ "${{ matrix.arch }}" = "arm64" ]; then
            sudo dpkg --add-architecture arm64
            sudo apt-get update
            sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu
            sudo apt-get install -y libgtk-3-dev:arm64 libwebkit2gtk-4.1-dev:arm64
          else
            # Verify webkit2gtk-4.1 is installed for amd64
            pkg-config --modversion webkit2gtk-4.1 || (echo "webkit2gtk-4.1 not found" && exit 1)
          fi
      
      - name: Install Windows dependencies
        if: matrix.platform == 'windows'
        run: |
          choco install mingw nsis -y
          # For ARM64 builds, we rely on Go's cross-compilation capabilities
          # CGO cross-compilation for Windows ARM64 is complex and may not work reliably
          if ("${{ matrix.arch }}" -eq "arm64") {
            Write-Host "Building for ARM64. Note: This may have limited CGO support."
          }
        shell: pwsh
      
      - name: Install Wails
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest
      
      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci
      
      - name: Build frontend (required for embed)
        working-directory: ./frontend
        run: npm run build
      
      - name: Build application (Linux)
        if: matrix.platform == 'linux'
        run: |
          if [ "${{ matrix.arch }}" = "arm64" ]; then
            export CC=aarch64-linux-gnu-gcc
            export CXX=aarch64-linux-gnu-g++
            export CGO_ENABLED=1
            export GOOS=linux
            export GOARCH=arm64
            export PKG_CONFIG_PATH=/usr/lib/aarch64-linux-gnu/pkgconfig
          fi
          wails build -clean -ldflags "-s -w" -platform ${{ matrix.platform }}/${{ matrix.arch }} -tags webkit2_41
      
      - name: Build application (Windows)
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          # For ARM64, set cross-compilation environment
          # Note: WebView2 on Windows may have issues with cross-compilation
          if ("${{ matrix.arch }}" -eq "arm64") {
            $env:CGO_ENABLED = "0"  # Disable CGO for ARM64 cross-compilation
            $env:GOOS = "windows"
            $env:GOARCH = "arm64"
          }
          wails build -clean -ldflags "-s -w" -platform ${{ matrix.platform }}/${{ matrix.arch }}
      
      - name: Build application (macOS)
        if: matrix.platform == 'darwin'
        run: |
          # macOS runners can build universal binaries natively
          # This includes both amd64 and arm64 architectures
          wails build -clean -ldflags "-s -w" -platform ${{ matrix.platform }}/${{ matrix.arch }}
      
      - name: Create installer (Windows)
        if: matrix.platform == 'windows'
        run: |
          # Find NSIS installation
          $nsisPath = Get-Command makensis -ErrorAction SilentlyContinue
          if (-not $nsisPath) {
            # Try common installation paths
            $possiblePaths = @(
              "C:\Program Files (x86)\NSIS\makensis.exe",
              "C:\Program Files\NSIS\makensis.exe"
            )
            foreach ($path in $possiblePaths) {
              if (Test-Path $path) {
                $nsisPath = $path
                break
              }
            }
          } else {
            $nsisPath = $nsisPath.Source
          }
          
          if (-not $nsisPath) {
            Write-Error "NSIS not found"
            exit 1
          }
          
          Write-Host "Using NSIS at: $nsisPath"
          
          # Update version and architecture in installer script
          $version = "${{ needs.create-release.outputs.version }}"
          $arch = "${{ matrix.arch }}"
          $installerPath = "build/windows/installer.nsi"
          
          if (Test-Path $installerPath) {
            $content = Get-Content $installerPath -Raw
            $content = $content -replace '!define APP_VERSION ".*"', "!define APP_VERSION `"$version`""
            $content = $content -replace 'OutFile ".*"', "OutFile `"..\bin\MrRSS-$version-windows-$arch-installer.exe`""
            Set-Content $installerPath $content
            
            # Build NSIS installer
            & $nsisPath $installerPath
            
            if ($LASTEXITCODE -ne 0) {
              Write-Error "NSIS build failed with exit code $LASTEXITCODE"
              exit 1
            }
          } else {
            Write-Warning "Installer script not found at $installerPath"
            exit 1
          }
        shell: pwsh
        continue-on-error: true
      
      - name: Create installer (Linux)
        if: matrix.platform == 'linux'
        run: |
          chmod +x build/linux/create-appimage.sh
          ARCH=${{ matrix.arch }} ./build/linux/create-appimage.sh
        continue-on-error: true
      
      - name: Create installer (macOS)
        if: matrix.platform == 'darwin'
        run: |
          chmod +x build/macos/create-dmg.sh
          ./build/macos/create-dmg.sh
        continue-on-error: true
      
      - name: Package application (Linux - tar.gz fallback)
        if: matrix.platform == 'linux'
        run: |
          cd build/bin
          if [ -f "MrRSS" ]; then
            tar -czf MrRSS-${{ needs.create-release.outputs.version }}-linux-${{ matrix.arch }}.tar.gz MrRSS
          else
            echo "Error: MrRSS binary not found"
            exit 1
          fi
      
      - name: Package application (Windows - zip fallback)
        if: matrix.platform == 'windows'
        run: |
          cd build/bin
          if (Test-Path "MrRSS.exe") {
            Compress-Archive -Path MrRSS.exe -DestinationPath MrRSS-${{ needs.create-release.outputs.version }}-windows-${{ matrix.arch }}.zip
          } else {
            Write-Error "MrRSS.exe not found"
            exit 1
          }
        shell: pwsh
      
      - name: Package application (macOS - zip fallback)
        if: matrix.platform == 'darwin'
        run: |
          cd build/bin
          if [ -d "MrRSS.app" ]; then
            # Create a zip of the .app bundle
            zip -r MrRSS-${{ needs.create-release.outputs.version }}-darwin-${{ matrix.arch }}.zip MrRSS.app
          else
            echo "Error: MrRSS.app not found"
            exit 1
          fi
      
      - name: Collect artifacts
        id: collect_artifacts
        shell: bash
        run: |
          cd build/bin
          artifacts=""
          
          # Check for installer
          if [ "${{ matrix.platform }}" = "windows" ]; then
            installer="MrRSS-${{ needs.create-release.outputs.version }}-windows-${{ matrix.arch }}-installer.exe"
            if [ -f "$installer" ]; then
              artifacts="$artifacts$installer,"
            fi
          elif [ "${{ matrix.platform }}" = "linux" ]; then
            installer="MrRSS-${{ needs.create-release.outputs.version }}-linux-${{ matrix.arch }}.AppImage"
            if [ -f "$installer" ]; then
              artifacts="$artifacts$installer,"
            fi
          elif [ "${{ matrix.platform }}" = "darwin" ]; then
            installer="MrRSS-${{ needs.create-release.outputs.version }}-darwin-${{ matrix.arch }}.dmg"
            if [ -f "$installer" ]; then
              artifacts="$artifacts$installer,"
            fi
          fi
          
          # Check for package
          if [ "${{ matrix.platform }}" = "windows" ]; then
            package="MrRSS-${{ needs.create-release.outputs.version }}-windows-${{ matrix.arch }}.zip"
          elif [ "${{ matrix.platform }}" = "darwin" ]; then
            package="MrRSS-${{ needs.create-release.outputs.version }}-darwin-${{ matrix.arch }}.zip"
          else
            package="MrRSS-${{ needs.create-release.outputs.version }}-linux-${{ matrix.arch }}.tar.gz"
          fi
          
          if [ -f "$package" ]; then
            artifacts="$artifacts$package,"
          fi
          
          echo "artifacts=$artifacts" >> $GITHUB_OUTPUT
          echo "Found artifacts: $artifacts"
      
      - name: Upload Release Assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.create-release.outputs.tag }}
          files: |
            build/bin/MrRSS-${{ needs.create-release.outputs.version }}-*
          token: ${{ secrets.GITHUB_TOKEN }}
          fail_on_unmatched_files: false
